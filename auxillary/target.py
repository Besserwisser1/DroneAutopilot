from math import sin, cos, pi, radians, sqrt, asin
#Характеристики дрона:
fov = 100 #Горизонтальный угол обзора камеры, в градусах
cam_angle = 30 #Угол, под которым расположена камера дрона относительно самого дрона, в градусах
aspect_ratio = 16/9 #Соотношение сторон экрана (ширины к высоте. В данном случае это 16 к 9, но можно выставить любое другое)

#Характеристики цели, на момент активации захвата:
tl = 100 #Расстояние до цели, в метрах
xp = 0.5 #Положение цели на экране по горизонтальной оси (от 0 до 1, где 0 - левый край экрана, а 1 - правый край экрана. 0.5, соответственно, середина экрана)
yp = 0.5 #Положение цели на экране по вертикальной оси (от 0 до 1, где 0 - нижний край экрана, а 1 - верхний край экрана. 0.5, соответственно, середина экрана)

#Функция, определяющая еденичный вектор направления на цель относительно взгляда летательного аппарата. Принимает углы angle (угол наклона камеры относительно летательного аппарата), pitch, yaw, возвращает компоненты x, y, z еденичного вектора напрвления взгляда камеры
def get_target_direction(pitch, yaw, x_agl, y_agl):
    nyaw = yaw + radians(x_agl)
    npitch = pitch + radians(y_agl)
    nx = cos(nyaw) * cos(npitch)
    ny = -sin(nyaw) * cos(npitch)
    nz = sin(npitch)
    return nx, ny, nz

#Функция, определяющая еденичный вектор направления, куда смотрит камера летательного аппарат. Принимает углы angle (угол наклона камеры относительно летательного аппарата), pitch, yaw, возвращает компоненты x, y, z еденичного вектора напрвления взгляда камеры
def get_view_direction(angle, pitch, yaw):
    nx = cos(yaw) * cos(pitch + angle)
    ny = -sin(yaw) * cos(pitch + angle)
    nz = sin(pitch + angle)
    return nx, ny, nz

#Функция, вычисляющая координаты цели в момент вызова. Принимает истинные координаты дрона, полученные через AirSim, pitch, yaw, а также угол обзора камеры, угол камеры, соотношение сторон изображения камеры, расстояние до цели, положение на экране, в процентах. Возвращает абсолютные координаты цели
def get_target_position(cx, cy, cz, pitch, yaw, fov, cam_angle, aspect_ratio, tl, xp, yp):
    x_agl = (xp - 0.5) * fov
    y_agl = (yp - 0.5) * (fov / aspect_ratio) + cam_angle
    nx, ny, nz = get_target_direction(pitch, yaw, x_agl, y_agl)
    tx = cx + nx * tl  # Знак изменен обратно
    ty = cy + ny * tl
    tz = cz - nz * tl
    return tx, ty, tz

#Функция, вычисляющая изменения положения цели на виртуальной камере дрона по координатам, полученным в момент наведения. Принимает истинные roll, pitch и yaw дрона, истинные относительные координаты дрона x, y и z из AirSim, а также x, y, z цели (вычесленные при наведении функцией get_ttarget_position), кроме того угол обзора камеры, соотношение сторон видео и угол наклона камеры, относительно дрона. Возвращает позицию точки цели на экране дрона (x, y, то есть по координату по ширине и высоте, 0 до 1. Если координата вне этого диапазона, значит цель на видео в данный момент не видна, вышла из поля зрения)
def get_onvideo_point_position(roll, pitch, yaw, cx, cy, cz, tx, ty, tz, fov, aspect_ratio, cam_angle):
    #вычисляем вектор до цели
    tvx = tx - cx
    tvy = ty - cy
    tvz = tz - cz
    tvs = sqrt(pow(tvx, 2) + pow(tvy, 2) + pow(tvz, 2))
    #нормализуем вектор до цели
    tvx /= tvs
    tvy /= tvs
    tvz /= tvs
    nx, ny, nz = get_view_direction(cam_angle, pitch, yaw) #вычисляем вектор напревления взглляда центра камеры дрона
    #Вычисляем горизонтальный и вертикальный углы, относительно дрона, в радианах
    px_agl = asin(tvx) - asin(nx) #Не уверен я, что это правильно. Возможно нужно было взять tvy и ny вместо tvx и nx, не пому понять в чём разница
    py_agl = asin(tvz) - asin(nz)
    px = px_agl / radians(fov)
    py = px_agl / radians(fov / aspect_ratio)
    return px, py